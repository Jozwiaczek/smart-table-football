\chapter{Aplikacja}
\label{ch:funplenop}
W tym rozdziale zostanie przedstawiony system, jego główne funkcjonalności oraz sposób uruchomienia.

System jest podzielony na 7 pakietów, tym samym w tym rozdziale każda sekcja będzie omawiała pojedynczy pakiet.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/diagrams/packages_structure.png}
  \caption{Struktura pakietów}
  \label{fig:mobile}
\end{figure}


\section{Przygotowanie projektu na komputerze}

Szczegółowy opis instalacji oraz uruchomienia każdej z paczek zostanie przedstawiony w sekcjach poniżej.
Poniższy sposób uruchomienia opisuję w podejściu jednego Raspberry oraz osobnego komputera w tej samej sieci lokalnej . Cały proces uruchomienia może zostać zrealizowany na jednym Raspberry lecz trwa to znacznie dłużej niż w przypadku pierwszego rozwiązania. Paczki `table` oraz `table-manager` muszą zostać uruchomione na Raspberry Pi. Zalecanym jest by proces przygotowywania projektu przeprowadzić zgodnie z poniszą kolejnością opisywanych paczek.

\subsection{Wymagane narzędzia}
Przed przejściem do instalacji paczek na komputerze, użytkownik powinien sprawdzić obecność oraz wersje potrzebnych w uruchomienia narzędzi i oprogramowania.

\begin{itemize}
	\item \href{https://nodejs.org/en/}{Node.js} - Minimalna wersja 12 (Do tej instalacji zalecanym jest użycie menadżera wersji node - \href{https://github.com/nvm-sh/nvm}{NVM})
	\item \href{https://yarnpkg.com/}{Yarn} - Menadżer pakietów i zależności. W projekcie jego rolą jest instalacja zewnętrznych pakietów oraz zarządzanie workspacesami.
	\item \href{https://www.docker.com/}{Docker} - W projekcie odpowiada za konteneryzacje instancji bazy danych. Potrzebne tylko w środowisku uruchomienia paczki 'api'.
\end{itemize}

\subsection{Zewnętrzne serwisy}

\begin{itemize}
	\item \href{https://nodejs.org/en/}{Google Drive} - Zapis powtórek wideo z meczy.
	\item \href{https://sendgrid.com/}{SendGrid} - Serwis mailingowy (Opcjonalny - Potrzebny tylko w wersji produkcyjnej)
	\item \href{https://ethereal.email/}{Etheral} - Testowy serwis mailingowy (Działa tylko lokalnie)
\end{itemize}

\subsubsection{\href{https://developers.google.com/drive/api/v3/enable-drive-api}{Google Drive}}

W celu umożliwienia systemowi przechowywanie wideo nagrań odtwarzających sytuacje z zapisanych goli podczas meczu należy skonfigurować zewnętrzny serwis w którym przechowywane są pliki wideo. Serwis, który zdecydowałem się zastosować jest Google Drive. W celu zintegrowania tego systemu należy:

\begin{itemize}
	\item Stworzyć lub/i zalogować się do istniejącego konta Google.
	\item Zalogować się w developerskiej konsoli Google
	\item Utworzyć nowy projekt
	\item W \href{https://developers.google.com/drive/api/v3/enable-drive-api}{Google API Console} uaktywnić interfejs 'Drive API' w wersji 3.
	\item W zakładce 'Dane logowania' utworzyć nowe konto usługi
	\item Po utworzeniu nowego konta nalezy utworzyć nowy klucz prywatny dla nowego konta
  \item Po uzyskaniu nowego klucza Google drive API należy go zapisać  (będzie potrzebny w dalszej części przygotowywania projektu, w sekcji 'Zmienne środowiskowe'). Klucz powinien być w postaci: \newline "-----BEGIN PRIVATE KEY-----......-----END PRIVATE KEY-----".
\end{itemize}


\subsubsection{\href{https://sendgrid.com/}{SendGrid} - Opcjonalny - Dla wersji produkcyjnej}

SendGrid jest serwisem mailingowym, który pozwala na zarządzanie oraz wysłkę maili w systemie. W celu umożliwienia działania wysyłki maili, serwer wymaga klucza API. W celu uzyskania własnego klucza API należy:

\begin{itemize}
	\item Stworzyć lub/i zalogować się do istniejącego konta SendGrid.
	\item W zakładce 'Settings' -> 'API keys', wygenerować nowy klucz API.
	\item Po uzyskaniu nowego klucza API dla serwisu SendGrid należy go zapisać (będzie potrzebny w dalszej części przygotowywania projektu, w sekcji 'Zmienne środowiskowe').
\end{itemize}

\subsubsection{\href{https://ethereal.email/}{Ethereal} - Dla wersji lokalnej}

Ethereal jest serwisem przeznaczonym do testowania usług mailngowych w szczególności ukierunkowanym na 'Nodemailer' (moduł w node.js), który jest wykorzystywany w systemie. W tym miejscu będą pojawiać się wszystkie maile z podglądem, które w środowisku produkcyjnym były by wysyłane do użytkowników.

W celu skonfigurowania tego serwisu z całym systemem należy zalogować się na stronie \url{https://ethereal.email} z mailem
'lou.hayes45@ethereal.email' oraz hasłem 'aUjsd6d31hMM5X9AnZ'. W przypadku problemów należy utworzyć nowe konto, a następnie automatycznie nowo utworzony email oraz hasło podmienić w projekcie w 'packages/api/config/default.json' w obiekcie mailer.auth, gdzie user to nowy mail oraz pass to nowe hasło.

\subsection{Zmienne środowiskowe}

Konfiguracja zmiennych środowiskowych realizowana jest na potrzeby ukrywania wrazliwych danych w systemie.
Do odczytu zmiennych środowiskowych zastosowałem paczkę 'dotenv', która umożliwia odczytywanie zmiennych ze środowiska.

W każdym pakiecie (poza 'core' oraz 'ui-components') znajduję się plik .env.example. Należy skopiować te pliki w każdym z pakietów oraz w tym samym miejscu wkleić go z nazwą '.env'. Po skopiowaniu wspomnianych plików należy je uzupełnić wedle przykładu lub wedle instrukcji zawartych dla każdego pakietu w pliku 'README.md'. W tym kroku należy użyć danych uzyskanych z sekcji 'Serwisy zewnętrzne'.

\subsection{Instalacja zależności paczek}

W tym kroku w pierwszej kolejności należy upewnić się prawidłowego działania oraz wersji NodeJS oraz Yarn. W celu takowego sprawdzenia należy w konsoli wpisać 'yarn -v' oraz 'node -v'. Wynikiem obydwu tych komend powinna być aktualnie zainstalowana wersja. W przeciwnym wypadku należy ponownie zainstalować te narzędzia.
Ze względu na podejście architektury systemu jako mono-repozytorium w celu instalacji zewnętrznych zależności, będąc w katalogu głównym projektu w konsoli wpisać `yarn`. Komenda ta zainstaluje zależności w folderze node-modules dla wszystkich 7 paczek. Jednocześnie podejście to pozwala na ograniczenie ilości zajmowanego miejsca ponieważ duplikaty tych samych wersji zależności instalowane są jednorazowo dla wszystkich paczek.


\section{Core}
Paczka 'Core' reprezentuje zestaw stałych oraz modeli używanych w systemie. Jej zastosowanie pozwala na uniknięcie błędów związanych z brakiem typowania występującego w wybranym języku programowania
JavaScript. W tym przypadku paczka Core nie wymaga żadnej konfiguracji.

\subsection{Stałe}
Stałe są zestawem obiektów, które przedstawiają stałe elementy wykorzystywane we wszystkich paczkach. Przykładowo `socketEvents` opisuje wszystkie zdefiniowane wydarzenia soketów w systemie.

\subsection{Modele}

Modele reprezentują wszystkie schematy oraz encje w systemie.
Schematy są wykorzystywane w modelach współdzieląc w ten sposób wspólne atrybuty. Pozostałe modele reprezentują wszystkie encje w systemu, które mają zaimplementowane serwisy oraz są przechowane w pamięci systemu lub bazie danych.

\section{API}
Pakiet `api` zawiera w sobie główny serwer całego systemu. Jest on sercem, szefem or mostem między wszystkimi pakietami.

\subsection{Docker}
Przed uruchomieniem tej paczki należy przygotować wirtualny kontener w dockerze z bazą danych. W pierwszym kroku należy upewnić się o zainstalowanym i uruchomionym Dockerze.

Powinno zwrócić aktualnie zainstalowaną wersje dockera (W przypadku problemów zainstalować ponownie dockera):
\begin{lstlisting}
docker -v
\end{lstlisting}

Powinno zwrócić informacje o aktualnie działającym lokalnie serwerze dokera (W przypadku błędu, upewnić się czy proces dockera został prawidłowo uruchomiony):
\begin{lstlisting}
docker info
\end{lstlisting}

Pobieranie najnowszego oficjalnego obrazu Dockera dla bazy danych MongoDB:

\begin{lstlisting}
docker pull mongo
\end{lstlisting}

Uruchom kontener Docker za pomocą polecenia run przy użyciu obrazu mongo:

\begin{lstlisting}[breaklines=true]
docker run -it -v $(pwd)/data/db:/data/db -p 27017:27017 --name mongodb -d mongo
\end{lstlisting}

W celu uruchomienia/zatrzymania kontenera należy użyć gotowego skryptu wewnątrz folderu 'packages/api':

\begin{lstlisting}
# Uruchomienie
yarn start:db

# Zatrzymanie
yarn stop:db
\end{lstlisting}

W celu sprawdzenia uruchomionych kontenerów w dockerze (Przed uruchomieniem powinno wyświetlić rekord w liście z nazwą 'mongodb'):

\begin{lstlisting}
docker container ls
\end{lstlisting}

\subsection{Aplikacja serwera}

Posiadając uruchomiony wirtualny kontener z bazą danych w konsoli należy przejść do folderu 'packages/api' oraz wpisać nastepującą komendę w celu uruchomienia serwera:

Uruchamia serwer:
\begin{lstlisting}
yarn start
\end{lstlisting}

Uruchamia serwer w trybie śledzenia zmian (automatyczny i natychmiastowy restart serwera podczas wykrytych zmian w kodzie źródłowym):
\begin{lstlisting}
yarn start:dev
\end{lstlisting}

Po prawidłowym wpisaniu komendy uruchomienia, serwer w konsoli powinien zwrócić informacje pod jakim adresem URL aktualnie działa oraz następnie informacje o prawidłowym połączeniu z bazą danych.


Pod wskazanym w konsoli adresem powinna ukazać się strona główna serwera.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/api/stf_api_home.png}
  \caption{Strona Główna Serwera pakietu 'api'}
  \label{fig:mobile}
\end{figure}


\section{Table Manger}
Pakiet 'table-manager' jest odpowiedzialny za zarządzanie procesem działania stołu. Dzięki temu pakietowi jesteśmy w stanie zdalnie uruchamiać, restartować, aktualizować stół oraz analizować logi z działającego procesu aplikacji z pakietu 'table' (z panelu administratora), która ta dopiero odpowiada za logikę działania systemu po stronie Raspberry Pi. Tym samym ta i następna sekcja będzie stricte związana z częścią fizyczną w związku z tym całe przygotowanie powinno odbyć się na Przygotowanym Raspberry Pi.

\subsection{Elektronika}

Paczki 'table-manager' oraz 'table' wymagają fizycznego sprzętu w postaci:

\begin{itemize}
	\item Raspberry Pi z zainstalowanym systemem operacyjnym
	\item Kamera - Zalecana kamera do systemu to dedykowana kamera 'Camera Module V2' do Rasberry Pi. Kamera na usb, też zadziała.
	\item Sensory do bramek indykujące strzelone gole
	\item Kable połączniowe
	\item Diody LED - Są one opcjonalne ale również zalecane. System zapewnia obsługę 5 diód w 4 różnych kolorach w celu odzwierciedlania różnych stanów systemu podczas swojego działania.
\end{itemize}

W tej sekcji zostanie omówione podłączenie kamery, sensorów bramek oraz diod LED.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/hardware/prototyp-bramki.jpg}
  \caption{Podłączony prototyp bramki}
  \label{fig:mobile}
\end{figure}

\subsubsection{Kamera}

Kamerę należy podłączyć fizycznie do Raspberry poprzez natywny moduł kamery lub USB.

\subsubsection{Sensory bramek}

W celu podłączenia sensorów bramek należy podłączyć 2 czujniki przerwania wiązki IR. Zaprojektowany model bramki przewiduje sensor o wymiarach 20mm x 10mm x 8 mm. W przypadku chęci przetestowania działania systemu można podłączyć zwykłe przyciski, które będą imitowały działanie sensorów.


\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/hardware/sensor.jpg}
  \caption{Podłączony czujnik przerwania wiązki IR}
  \label{fig:mobile}
\end{figure}


\subsubsection{Diody LED - Opcjonalne}
System STF zapewnia obsługę 5 diod indykujących stan działania stołu/systemu.

\begin{table}[h!]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\multicolumn{1}{|c|}{\textbf{Nazwa}} & \multicolumn{1}{c|}{\textbf{GPIO}} & \textbf{Zalecany kolor} & \textbf{Opis} \\ \hline
\textit{TABLE\_MANAGER\_LIGHT} & 23 & Biały/Niebieski & Działanie table-manger \\ \hline
\textit{GATE\_A\_LIGHT} & 21 & Czerwony & Gol dla zespołu A \\ \hline
\textit{GATE\_B\_LIGHT} & 25 & Czerwony & Gol dla zespołu B \\ \hline
\textit{MATCH\_LIGHT} & 15 & Żółty/Pomarańczowy & Stan meczu \\ \hline
\textit{TABLE\_LIGHT} & 13 & Zielony & Działanie stołu \\ \hline
\end{tabular}
\caption{Tabela diod z domyślnymi GPIO}
\end{table}

Przygotowanie diod wymaga podłączenia pod wskazanymi w tabeli wyżej GPIO. System oferuje również możliwość podłączenia diod pod dowolne GPIO,  w tym celu należy zmodyfikować plik GPIO.js dla paczki 'table-manger' oraz 'table'.

\subsection{Oprogramowanie}

\subsubsection{Raspberry}

Następnym krokiem jest zaktualizowanie systemu, dodatków i aplikacji na raspberry komendą:

\begin{lstlisting}
sudo apt update
sudo apt full-upgrade
\end{lstlisting}

\subsubsection{Kamera}

Uruchomienie wsparcia kamery wymaga włączenie odpowiedniej opcji w konfiguracji, w tym celu w terminalu należy wpisać:

\begin{lstlisting}
sudo raspi-config
\end{lstlisting}

Po uruchomieniu tej komendy pojawi się okno z możliwością konfiguracji Raspberry. Strzałkami klawiatury nalezy wybrać opcje 'Interfacing Options',  zaznaczyć 'Camera' oraz zatwierdzić akcję oraz zrestartować urządzenie.

W celu sprawdzenia poprawności działania kamery można użyć komendy:

\begin{lstlisting}
raspistill -v -o test.jpg
\end{lstlisting}

Komenda ta powinna wykonać zdjęcie oraz zapisać je w katalogu domowym pod nazwą test.jpg.

\subsubsection{NVM}

W celu instalacji node w systemie Raspberry najlepiej jest skorzystać z NVM (Node Version Manager), który pozwala na prostą instalację node oraz szybkie przełączanie pomiędzy jego różnymi wersjami.

Pobranie NVM:
\begin{lstlisting}
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash
\end{lstlisting}

Konfiguracja NVM:
\begin{lstlisting}[breaklines=true]
export NVM_DIR="$HOME/.nvm"
 [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
 [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion
\end{lstlisting}

Sprawdzenie działania:
\begin{lstlisting}
nvm -v
\end{lstlisting}

Instalacja Node.js w wersji 12 poprzez NVM:
\begin{lstlisting}
nvm install 12
\end{lstlisting}

\subsubsection{Yarn}
W celu możliwości zainstalowania zależności i zarządzania pakietami należy zainstalować menadżer pakietów Yarn.

Instalacja yarn:
\begin{lstlisting}[breaklines=true]
curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -echo "deb https://dl.yarnpkg.com/debian/ stable main" | sudo tee /etc/apt/sources.list.d/yarn.list
\end{lstlisting}

Nastepnie:
\begin{lstlisting}
sudo apt update && sudo apt install --no-install-recommends yarn
\end{lstlisting}

Sprawdzenie poprawności działania Yarn (powinno zwrócić aktualnie zainstalowaną wersje).
\begin{lstlisting}
yarn -v
\end{lstlisting}


\subsubsection{\href{https://www.raspberrypi.org/documentation/usage/camera/raspicam/raspivid.md}{MP4Box}}

Rozszerzenie CLI, która pozwala na konwersje wideo z formatu .h264 do .mp4. Potrzebne tylko w środowisku uruchomienia paczek 'table' oraz 'table-manager'.

\begin{lstlisting}
  sudo apt install -y gpac
\end{lstlisting}


\subsubsection{Automatyczny start - opcjonalne}
Źródło: https://www.raspberrypi.org/documentation/linux/usage/cron.md

Cron jest narzędziem wbudowanym w domyślny system Raspberry Pi. Pozawala on na wykonywanie zaplanowanych zadań w systemie. Z pomocą tego narzędzia jest realizowana możliwość automatycznego uruchomiania pakietu 'table-manager'.

Uruchomienie oraz konfiguracja crontab:
\begin{lstlisting}
crontab -e
\end{lstlisting}

Na końcu otworzonego pliku konfiguracyjnego należy dodać poniższą linijkę:
\begin{lstlisting}[breaklines=true]
@reboot cd /home/pi/smart-table-football/packages/table-manager && yarn start &
\end{lstlisting}

\subsection{Zmienne środowiskowe}
TODO:
- ze trzeba tak samo jak na komputerze co jakie i po co
- sprawdzić w apce czy w table-managerze potrzebne


\subsection{Uruchomienie}

Instalowanie zależności:

\begin{lstlisting}
yarn
\end{lstlisting}

W przypadku skonfigurowania automatycznego startu wystarczy uruchomić ponownie raspberry pi. W przeciwnym wypadku w konsoli należy przejść do folderu 'packages/table-manger' oraz wpisać:

\begin{lstlisting}
yarn start
\end{lstlisting}

\section{Table}
Pakiet 'table' jest sercem działania systemu po stronie 'hardware'u'.

Uruchomieniem jednak tego pakietu zajmuje się uruchomiony proces paczki 'table-manager', tym samym paczka ta nie wymaga manualnego uruchomienia. Możliwe jest uruchomienie tego pakietu bez użycia menadżera (przygotowanie takie samo jak w przypadku poprzedniego pakietu), jednak nie jest to zalecane ze względu na brak możliwości zarządzania działaniem stołu w tym przypadku z poziomu admin panelu.

\section{UI Components}
Pakiet 'ui-components' jest zbiorem komponentów oraz konfiguracji wykorzystywanych przez paczki Admin oraz Player. Jednocześnie oparta jest o Storybooka, który umożliwia budowanie graficznych komponentów w odizolowaniu (bez logiki).

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/ui-components/storybook.png}
  \caption{Działanie storybook}
  \label{fig:mobile}
\end{figure}

W celu uruchomienia storybooka, w konsoli należy przejść do folderu 'packages/ui-components' oraz wpisać:

\begin{lstlisting}
yarn storybook
\end{lstlisting}

Ze względu na fakt importowania komponentów oraz konfiguracji w innych pakietach kod źródłowy musi być transpilowany z każdą zmianą. Domyślnie proces budowania paczki jest realizowany z każdym instalowaniem zależności w projekcie (Patrz: 4.1.5). W przypadku chęci wprowadzenia zmian w tym pakiecie, za każdym razem należy wykonać komendę:

Transpiluje kod źródłowy paczki:
\begin{lstlisting}
yarn build
\end{lstlisting}

Uruchamia transpilacje w trybie śledzenia zmian:
\begin{lstlisting}
yarn build:watch
\end{lstlisting}

\section{Uruchamianie pakietu Admin oraz Player}
Ze względu na ten sam proces uruchomienia pakietów 'admin' oraz 'player', zostanie omówione to w jednej sekcji, następne każdy pakiet z osobna zostanie omówiony.

Obydwie pakietu zbudowane są u podstawy w oparciu o biblioteki:

\begin{itemize}
    \item React
	\item Create React App
	\item React Admin
	\item Material UI
	\item Socket.IO
\end{itemize}


W celu uruchomienia omawianych pakietów należy przejść w konsoli do pakietu 'player' oraz 'admin oraz wpisać:

\begin{lstlisting}
yarn start
\end{lstlisting}

Powyższy skrypt uruchomi automatycznie aplikacje gracza w przeglądarce. Istnieje również możliwość skonfigurowania działania aplikacji w sieci lokalnej (np. na telefonie). W tym celu w pliku '.env' w zmiennej 'REACT\_APP\_API\_URL' należy wpisać 'http://{ADRES\_IP\_API}:8080'. Adres ten powinien wskazywać na IP urządzenia na którym uruchomiony jest pakiet 'api'. Dzięki temu aplikacja będzie wiedziała w jaki sposób komunikować się w sieci lokalnej.

Obydwa aplikacje oferują również możliwość działania w trybie aplikacji natywnej dzięki podejściu PWA. Przykładowo w przeglądarce Chrome na komputerze, użytkownik podczas korzystania z aplikacji powinien w pasku wyszukiwania widzieć ikonę plusa, która sygnalizuje możliwość zainstalowania lokalnie aplikacji. Tym samym na telefonie podczas korzystania z aplikacji powinna po czasie wyświetlić się informacja o możliwości zainstalowania aplikacji w ekranie głównym.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/player/PWA_promt.png}
  \caption{Powiadomienie o instalacji aplikacji}
  \label{fig:mobile}
\end{figure}


\section{Admin}

Panel administratora jest aplikacją opartą o bibliotekę 'Create-React-App', która umożliwia pracę nad aplikacją frontend'ową bez żadnej dodatkowej konfiguracji. Dzięki CRA, praca nad projektem zachowuje standardy oraz optymalizacje aplikacji oraz umożliwia szybkie rozpoczęcie pracy z aplikacją dzięki możliwości generowania początkowego etapu projektu. Kolejną technologią zastosowaną w tym pakiecie jest otwarta i darmowa biblioteka 'React-Admin'. Wspomniana biblioteka umożliwia budowanie aplikacji (głównie paneli administracyjnych) w bardzo szybki sposób, z gotowych komponentów napisanych w React'cie. Dzięki temu wszystkie operacje CRUD (Create, Read, Update, Delete), zostały zrealizowane zgodnie z zalecanymi praktykami UI oraz umożliwiło to skupienie się na bardziej złożonych elementach aplikacji.

W celu utworzenia pierwszego użytkownika z rolą administratora należy w edytorze kodu w pliku 'pacakges/api/src/middleware/index.js' odkomentować fragment kodu poprzedzony komentarzem 'CREATE FIRST ADMIN', następnie przy uruchomionym pakiecie wejść na adres serwera: 'http://localhost:8080/create-first-admin', co utworzy nowego administratora z mailem: 'admin@stf.com' oraz hasłem: '123123'. W celu uniknięcia błędów należy natychmiastowo po utworzeniu pierwszego użytkownika ponownie za komentować fragment kodu.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/admin/adminsList.png}
  \caption{Zarządzanie zasobami w panelu administratora}
  \label{fig:mobile}
\end{figure}

System umożliwia wysyłanie maili do użytkowników systemu z poziomu panelu administratora. Upraszcza to formę komunikacji z użytkownikami.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/admin/mailer.png}
  \caption{Wysyłanie maila w panelu administratora}
  \label{fig:mobile}
\end{figure}

Poza operacjami 'CRUD', drugim najważniejszym elementem pakietu 'admin' jest zakładka 'tables'. Umożliwia ona zdalne zarządzanie stołem. W skład wszystkich funkcji, które można znaleźć w tej zakładce wliczają się:

\begin{itemize}
	\item Status Menadżera (włączony/wyłączony)
	\item Status Stołu (włączony/wyłączony)
	\item Uruchamianie ponowne całego Raspberry Pi
	\item Włączenie/Wyłączenie serwera stołu
	\item Aktualizacja oprogramowania stołu (pobieranie zmian ze zdalnego repozytorium na Github.com)
	\item Informacja o ostatniej lokalnej aktualizacji
	\item Logi systemu
	\item Możliwość czyszczenia lokalnego logów systemu
\end{itemize}

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/admin/table-manager.png}
  \caption{Zarządzanie stołem w panelu administratora}
  \label{fig:mobile}
\end{figure}

\section{Player}

Najważniejszym elementem z punktu widzenia użytkownika jest pakiet 'player'. Jest to główna aplikacja frontendowa łącząca użytkownika z wszystkimi pozostałymi pakietami. U podstawy oparta jest o te same technologie co pakiet 'admin', tzn. CRA, React, React-Admin. W odróżnieniu jednak od pakietu 'admin' posiada ona wiele dodatkowych oraz zmodyfikowanych elementów w kontekście 'React-Admin'.

\subsection{Logowanie}

Po uruchomieniu aplikacji zgodnie z instrukcjami w sekcji 'Uruchamianie pakietu Admin oraz Player', pierwszym widokiem aplikacji powinien być ekran logowania. Domyślnie w bibliotece 'React-Admin' znajduje się wbudowany widok logowania (taki jak w pakiecie 'admin'). W przypadku jednak tego pakietu został utworzony osobny widok logowania w celu umożliwienia nawigacji do widoku rejestracji lub przypomnienia hasła. Takie podejście zapewnia użytkownikowi pełną rolę nad cyklem życia konta. W prosty sposób użytkownik może utworzyć swoje konto lub zresetować bieżące hasło. Etap autoryzacji i autentykacji w aplikacji jest bardzo ważnym elementem pod względem utrzymywania bezpieczeństwa danych użytkowników.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/player/login.png}
  \caption{Formularz logowania}
  \label{fig:mobile}
\end{figure}

\subsection{Rejestracja}

 W celu dodania zintegrowanego z panelem logowania formularzu rejestracji musiało zostać to nadpisane. Oprócz logowania i rejestracji w początkowych komponentach widocznych dla użytkownika znajduje się również formularz przypomnienia hasła.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/player/registration.png}
  \caption{Formularz rejestracji}
  \label{fig:mobile}
\end{figure}

\subsection{Potwierdzenie konta}

Ze względów bezpieczeństwa w systemie zostało wprowadzone wymaganie potwierdzenia konta mailowego. Zamiarem tego ograniczenia jest zmniejszenie potencjalnych prób zakładania wielu kont przez pojedynczych użytkowników lub botów. Użytkownik, który nie potwierdził swojego konta mailowego ma dostęp do aplikacji, lecz nie może tworzyć nowych zespołów lub uczestniczyć w rozgrywce.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/api/verify_email.png}
  \caption{Mail z prośbą potwierdzenia maila}
  \label{fig:mobile}
\end{figure}

Użytkownik klikając w link w mailu zostaje przeniesiony do widoku potwierdzającego weryfikacje maila. Próbując otworzyć drugi raz ten sam link użytkownik pewien zobaczyć informacje o błędzie. Po udanej weryfikacji użytkownicy mogą tworzyć własne zespoły oraz uczestniczyć w grach.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/player/verfied_emial_confirmation.png}
  \caption{Widok potwierdzonego maila}
  \label{fig:mobile}
\end{figure}

\subsection{Ekran Główny}

Pierwszym widokiem po zalogowaniu się lub rejestracji (po rejestracji, użytkownik również zostaje przekierowany automatycznie do aplikacji) jest dashboard. Jest to miejsce w którym, zebrane są wszystkie najważniejsze dla gracza statystyki zbiorcze związane z meczami, galami oraz zespołami. W tym miejscu możemy zarówno utworzyć w szybki sposób nowy mecz ale również przejrzeć statystyki z ostatnio rozgrywanego.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/player/dashboard.png}
  \caption{Strona główna aplikacji gracza}
  \label{fig:mobile}
\end{figure}

Ze względu na założenie dostarczenia użytkownikowi najbardziej zbliżonych doświadczeń korzystania z aplikacji natywnej, podejście budowania interfejsu wykorzystuje założenia 'Material Design'. \href{Material Design}{https://material.io/design} jest zestawem zasad projektowania graficznego. Jako wsparcie tego systemu budowany interfejs wykorzystuje bibliotekę komponentów graficznych \href{Material-UI}{https://material-ui.com/}. Biblioteka ta została zaimplementowana w pełnym oparciu o wspomniany zestaw zasad. Jedną z wiodących zasad projektowania interfejsów dla stron internetowych jest 'mobile-first'. Mówi ona o tym, że w pierwszym etapie budowania aplikacji, wykonawca powinien skupić się na widoku mobilnym. Zasada ta wiąże się z dwoma kluczowymi rzeczami. Po pierwsze podczas pracy nad aplikacją, łatwiej jest myśleć od początku o widoku mobilnym jednocześnie z desktopowym ze względu na implementacje stylowania. Najczęściej przygotowanie obydwu wersji jednocześnie wiąże się ze znacznie skróconym czasem pracy. Drugą istotną rzeczą jest fakt pozycjonowania stron internetowych w wyszukiwarkach. Zoptymalizowane działanie, kolory oraz widoki są jednym z ważniejszych czynników kategoryzacji stron.

W głównym widoku aplikacji znajduję się: skrót tworzenia nowej gry, sekcja z ilością zespołów gracza oraz możliwością zaproszenia użytkownika poprzez maila, ogólne statystki z gier, skrót do wyników z ostatniego meczu.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/player/mobile_view.png}
  \caption{Strona główna na urządzeniach mobilnych}
  \label{fig:mobile}
\end{figure}

\subsection{Górny pasek aplikacji}

W górnym pasku aplikacji znajdują się między innymi 2 ikony sygnalizujące aktualną dostępność stołu (czy jest w użytkowaniu) oraz jego aktualny stan (czy jest włączony). Poza tymi ikonami użytkownik, z poziomu górnego paska może otworzyć/zamknąć menu, sprawdzić powiadomienia, odświeżyć stan aplikacji lub wejść w ustawienia aplikacji.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/player/appbar.png}
  \caption{Główny pasek aplikacji ze statusem oraz dostępnością stołu}
  \label{fig:mobile}
\end{figure}

\subsection{Powiadomienia}

W pakiecie 'player' został zaimplementowany mechanizm powiadomień w celu informowania użytkowników o zaproszeniach do nowych zespołów, odrzuceniu własnych zaproszeń przez innych graczy lub ogólnych informacji od systemu. Sama logika wysyłania powiadomień znajduje się w pakiecie 'api'. Wysyłanie odbywa się przy pomocy jednej funkcji 'sendNotifications' zdefiniowanej w folderze 'utils'. W swoich argumentach przyjmuje ogólny kontekst biblioteki feathers, id gracza do którego ma trafić powiadomienie, wiadomość, typ oraz opcjonalnie link. Powiadomienia są osobnym serwisem ale dzięki wyniesieniu funkcji tworzenia pojedynczego powiadomienia jest to bardzo proste i re używalne w pozostałej części systemu.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/player/notifications.png}
  \caption{Widok listy powiadomień}
  \label{fig:mobile}
\end{figure}

\subsection{Ustawienia}

Aplikacja gracza umożliwia dostosowanie aplikacji względem języka aplikacji oraz motywu. Domyślnie motyw pobierany jest na podstawie tego zdefiniowanego w systemie/środowisku w którym uruchamiana jest aplikacja. Dzięki temu mając ustawiony w komputerze motyw ciemny, aplikacja gracza domyślnie uruchomi się z takim samym motywem.

Poza motywem, użytkownik może również dostosować wyświetlany język. Dzięki zdefiniowanej funkcji w bibliotece 'react-admin' zarządzanie i dodawanie nowych języków jest bardzo proste. W folderze i18n zostały zdefiniowane tłumaczenia dla języka angielskiego oraz polskiego. Idea tłumaczenia opiera się na określonej strukturze obiektu z tłumaczeniem konkretnych elementów, która jest taka sama dla wszystkich plików z tłumaczeniem. W celu wykorzystania tłumaczenia wewnątrz aplikacji należy skorzystać z funkcji 'useTranslate' pochodzącej z biblioteki React Admin, na początku komponentu wywołać ją oraz jej wynik przypisać do funkcji 'translate'. Zwróca funkcja umożliwi tłumaczenie konkretnie zadeklarowanych obiektów. Przykładowo wywołanie 'translate('pos.dashboard.title')', zwróci główny tytuł widniejący w ekranie głównym aplikacja w zależności od wybranego aktualnie języka.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/player/settings.png}
  \caption{Ustawienia gracza}
  \label{fig:mobile}
\end{figure}

\subsection{Profil gracza}

Użytkownik podczas korzystania z aplikacji może edytować swój profil oraz zarządzać swoim kontem w zakładce 'profil'. Sekcja ta została podzielona na 3 pod sekcje. Pierwsza (domyślnie wybrana) skupia informacje użytkownika, które są widziane przez innych graczy. Następną podsekcją są informacje nie edytowalne związane z kontem, w tym: powiązany email, status konta, data stworzenia i ostatniej aktualizacji. Ostatnią zakładką są akcje związane z kontem gracza. W tym miejscu użytkownik może zmienić swoje hasło, wysłać mail weryfikacyjny lub trwale usunąć swoje konto.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/player/userProfie.jpeg}
  \caption{Edycja profilu gracza}
  \label{fig:mobile}
\end{figure}

\subsection{Tworzenie zespołu oraz gry}

Każdy użytkownik, który zarejestruje się w aplikacji domyślnie posiada swój własny indywidualny zespół, z którym może rozpoczynać nowe rozgrywki. W celu utworzenia jednak zespołu dwuosobowego, wymaganym jest przejście do widoku tworzenia zespołu. W tym widoku gracz musi wpisać nazwę nowego zespołu oraz wpisać mail drugiego zarejestrowanego użytkownika (system pozwala na zaproszenie tylko zarejestrowanych graczy).

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/player/creating-team.png}
  \caption{Tworzenie nowego zespołu}
  \label{fig:mobile}
\end{figure}

W celu stworzenia nowej gry należy przejść do widoku 'gry' oraz kliknąć 'stwórz'. W widoku tworzenia nowej gry, gracz musi wybrać jeden ze swoich zespołów, zespół przeciwny oraz ilość sekund, która określa długość nagrań powtórek.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/player/create-match.png}
  \caption{Tworzenie nowej gry}
  \label{fig:mobile}
\end{figure}

\subsection{Widok gry}

Użytkownik po utworzeniu meczu lub wybraniu kontynuacji starego przechodzi do widoku gry. W jednym momencie w widoku gry może znajdować się wielu graczy. W celu rozpoczęcia rozgrywki jeden z graczy musi wcisnąć przycisk 'start'. W tym momencie zielona dioda podłączona do stołu powinna się zaświecić oraz licznik czasu powinien zacząć naliczanie czasu. Od tego momentu system oznacza stół jako zajęty, co dla innych graczy oznacza brak możliwości rozpoczęcia rozgrywki oraz zmianę ikony w górnym pasku aplikacji na stół zajęty.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/player/match.png}
  \caption{Główny widok gry}
  \label{fig:mobile}
\end{figure}

Po rozpoczęciu meczu, każdy gol, który zostanie strzelony będzie zapisany w systemie oraz zostanie nagrana jego powtórka z pomocą kamery. Podczas każdego gola, w pierwszej kolejności zapala się czerwona dioda przypisana do bramki. W następstwie zapalenia diody, nagranie bramki jest zapisywane na dysku Google oraz odtwarzane w widoku gry. Powtórka odtwarzana jest w tymczasowym powiadomieniu o nowym golu, w tym samym momencie, użytkownik może anulować ostatni gol.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/player/newgoal.png}
  \caption{Powiadomienie o nowym golu}
  \label{fig:mobile}
\end{figure}

\subsection{Historia goli w grze}

W ekranie gry, każdy użytkownik może w dowolnym momencie sprawdzić historie goli, która znajduję pod tablą z wynikiem. Lista goli pozwala na usuwanie oraz oglądanie powtórek wybranych goli.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/player/goals history.png}
  \caption{Historia goli w widoku gier}
  \label{fig:mobile}
\end{figure}

\subsection{Lista gier i zespołów}

W głównym menu aplikacji, dwoma ostatnimi elementami jest kolejno lista zespołów oraz lista gier aktualnie zalogowanego gracza. Obydwie listy implementują mechanizm sortowania (kliknięcie w nagłówek kolumny) oraz filtrowania po kluczowych polach tych zasobów. 
Dzięki ustandaryzowanemu podejściu w komunikacji serwera z aplikacją (REST) oraz implementacji biblioteki 'react-admin', funkcjonalności sortowania i filtrowania wymagają jedynie zadklarowania, które pola mają być brane pod uwagę (sortowanie domyślnie jest dla wszystkich elementów).

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/player/listFilters.png}
  \caption{Filtrowanie listy zespołów}
  \label{fig:mobile}
\end{figure}
