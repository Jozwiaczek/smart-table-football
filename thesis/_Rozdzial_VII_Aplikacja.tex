\chapter{Aplikacja}
\label{ch:application}
W tym rozdziale zostanie przedstawiony system, jego główne funkcjonalności oraz sposób uruchomienia.

System podzielony jest na siedem pakietów, tym samym w tym rozdziale każda sekcja będzie omawiała pojedynczy pakiet. Struktura pakietów została przedstawiona na ilustracji \ref{fig:packages-structure}

\section{Przygotowanie projektu na komputerze}
Szczegółowy opis instalacji oraz uruchomienia każdej z paczek zostanie przedstawiony w sekcjach poniżej.
Poniższy sposób uruchomienia opisuje w podejściu jednego Raspberry oraz osobnego komputera w tej samej sieci lokalnej. Cały proces uruchomienia może zostać zrealizowany na jednym Raspberry lecz trwa to znacznie dłużej niż w przypadku pierwszego rozwiązania. Paczki `table` oraz `table-manager` muszą zostać uruchomione na Raspberry Pi. Zalecanym jest by proces przygotowywania projektu przeprowadzić zgodnie z poniższą kolejnością opisywanych paczek.

\subsection{Wymagane narzędzia}
Przed przejściem do instalacji paczek na komputerze, użytkownik powinien sprawdzić obecność oraz wersje potrzebnych w uruchomienia narzędzi i oprogramowania.

\begin{itemize}
	\item Node - Minimalna wersja 12 (Do tej instalacji zalecane jest użycie menadżera wersji node - NVM). Opisany w rozdziale \ref{section:node}.
	\item Yarn - Menadżer pakietów i zależności. W projekcie jego rolą jest instalacja zewnętrznych pakietów oraz zarządzanie workspacesami.
	\item Docker - W projekcie odpowiada za konteneryzacje instancji bazy danych. Potrzebne tylko w środowisku uruchomienia paczki 'api'. Opisany w rozdziale \ref{section:docker}.
\end{itemize}

\label{subsection:externalServices}
\subsection{Zewnętrzne serwisy}
\begin{itemize}
	\item Google Drive API V3 - Zapis powtórek wideo z meczy. Opisany w rozdziale \ref{section:googleDrive}.
	\item SendGrid - Serwis mailingowy (Opcjonalny - Potrzebny tylko w wersji produkcyjnej). Opisany w rozdziale \ref{publication:sendgrid}.
	\item Etheral - Testowy serwis mailingowy (Działa tylko lokalnie). Opisany w rozdziale \ref{section:mailling}.
\end{itemize}

\subsubsection{Google Drive}
W celu umożliwienia systemowi przechowywania wideo nagrań odtwarzających sytuacje z zapisanych goli podczas meczu należy skonfigurować zewnętrzny serwis, w którym przechowywane są pliki wideo:

\begin{itemize}
	\item Stworzyć lub/i zalogować się do istniejącego konta Google;
	\item Zalogować się w developerskiej konsoli Google;
	\item Utworzyć nowy projekt;
	\item W konsoli Google API uaktywnić interfejs 'Drive API' w wersji 3;
	\item W zakładce \textit{Dane logowania} utworzyć nowe konto usługi;
	\item Po utworzeniu nowego konta należy utworzyć nowy klucz prywatny dla nowego konta;
  \item Po uzyskaniu nowego klucza Google drive API należy go zapisać  (będzie potrzebny w dalszej części przygotowywania projektu, w kroku \ref{subsection:envs}). Klucz powinien być w postaci: \newline \textit{-----BEGIN PRIVATE KEY-----\textbf{wartość klucza}-----END PRIVATE KEY-----}
\end{itemize}


\subsubsection{SendGrid - Opcjonalny - Dla wersji produkcyjnej}
W celu umożliwienia działania wysyłki e-maili, serwer wymaga klucza API. W celu uzyskania własnego klucza API należy:

\begin{itemize}
	\item Stworzyć lub/i zalogować się do istniejącego konta SendGrid;
	\item W zakładce \textit{Settings} -> \textit{API keys}, wygenerować nowy klucz API;
	\item Po uzyskaniu nowego klucza API dla serwisu SendGrid należy go zapisać (będzie potrzebny w dalszej części przygotowywania projektu, w sekcji \ref{subsection:envs}).
\end{itemize}

\label{application:preparation:etheral}
\subsubsection{Ethereal - Dla wersji lokalnej}
W celu skonfigurowania serwisu Etheral z całym systemem należy zalogować się na stronie \url{https://ethereal.email} z mailem
\textit{lou.hayes45@ethereal.email} oraz hasłem \textit{aUjsd6d31hMM5X9AnZ}. W przypadku problemów należy utworzyć nowe konto, a następnie automatycznie nowo utworzony email oraz hasło podmienić w projekcie w \textit{packages/api/config/default.json} w obiekcie \textit{mailer.auth}, gdzie user to nowy e-mail oraz pass to nowe hasło.

\label{subsection:envs}
\subsection{Zmienne środowiskowe}
Konfiguracja zmiennych środowiskowych realizowana jest na potrzeby ukrywania wrażliwych danych w systemie.
Do odczytu zmiennych środowiskowych zastosowano paczkę \textit{dotenv}, która umożliwia odczytywanie zmiennych ze środowiska.

W każdym pakiecie (poza \textit{core} oraz \textit{ui-components}) znajduje się plik \textit{.env.example}. Należy skopiować te pliki w każdym z pakietów oraz w tym samym miejscu wkleić go z nazwą \textit{.env}. Po skopiowaniu wspomnianych plików należy je uzupełnić zgodnie z przykładem lub według instrukcji zawartych dla każdego pakietu w pliku \textit{README.md}. W tym kroku należy użyć danych uzyskanych z sekcji \ref{subsection:externalServices}.

\subsection{Instalacja zależności paczek}
W tym kroku w pierwszej kolejności należy upewnić się o prawidłowości działania, wersji Node oraz Yarn. W celu takowego sprawdzenia należy w konsoli wpisać \textit{yarn -v} oraz \textit{node -v}. Wynikiem obydwu tych komend powinna być aktualnie zainstalowana wersja. W przeciwnym wypadku, należy ponownie zainstalować te narzędzia.
Ze względu na podejście architektury systemu jako monolitycznego repozytorium w celu instalacji zewnętrznych zależności, będąc w katalogu głównym projektu w konsoli należy wpisać \textit{yarn}. Komenda ta zainstaluje zależności w folderze node-modules dla wszystkich siedmiu pakietów. Jednocześnie podejście to pozwala na ograniczenie ilości zajmowanego miejsca, ponieważ duplikaty tych samych wersji zależności instalowane są jednorazowo dla wszystkich paczek.

\section{Core}
Paczka \textit{core} reprezentuje zestaw stałych oraz modeli używanych w systemie. Jej zastosowanie pozwala na uniknięcie błędów związanych z brakiem typowania występującego w wybranym języku programowania
JavaScript. W tym przypadku paczka Core nie wymaga żadnej konfiguracji.

\subsection{Stałe}
Stałe są zestawem obiektów, które przedstawiają stałe elementy wykorzystywane we wszystkich paczkach. Przykładowo \textit{socketEvents} opisuje wszystkie zdefiniowane wydarzenia socket'ów w systemie.

\subsection{Modele}
Modele reprezentują wszystkie schematy oraz encje w systemie.
Schematy są wykorzystywane w modelach współdzieląc w ten sposób wspólne atrybuty. Pozostałe modele reprezentują wszystkie encje systemu, które mają zaimplementowane serwisy oraz są przechowane w pamięci systemu lub bazie danych.

\section{API}
Pakiet \textit{api} zawiera w sobie główny serwer całego systemu. Jest on sercem, szefem oraz mostem między wszystkimi pakietami.

\subsection{Docker}
Przed uruchomieniem tej paczki należy przygotować wirtualny kontener w dockerze z bazą danych. W pierwszym kroku należy upewnić się o zainstalowanym i uruchomionym Dockerze.

Poniższa komenda wywołana w terminalu powinna zwrócić aktualnie zainstalowaną wersje Dockera (w przypadku problemów zainstalować ponownie Dockera):
\begin{lstlisting}[caption={Sprawdzenie zainstalowanej wersji Dockera}]
docker -v
\end{lstlisting}

Poniższa komenda wywołana w terminalu powinna zwrócić informacje o aktualnie działającym lokalnie serwerze dokera (w przypadku błędu, upewnić się czy proces Dockera został prawidłowo uruchomiony):
\begin{lstlisting}[caption={Wyświetlenie informacji o działającym dockerze}]
docker info
\end{lstlisting}

Poniższa komenda wywołana w terminalu pobiera najnowszą oficjalną wersję obrazu Dockera dla bazy danych MongoDB:

\begin{lstlisting}[caption={Pobranie obrazu dockera dla MongoDB}]
docker pull mongo
\end{lstlisting}

W terminalu uruchom kontener Docker za pomocą polecenia run przy użyciu obrazu mongo komendą:

\begin{lstlisting}[caption={Uruchomienie kontenera z bazą danych}]
docker run -it -v $(pwd)/data/db:/data/db -p 27017:27017 --name mongodb -d mongo
\end{lstlisting}

Po wykonaniu pierwszego uruchomienia, wszystkie następne uruchomienia/zatrzymania mogą odbywać się przy użyciu gotowego skryptu wewnątrz folderu 'packages/api', który korzysta z aliasu do stworzonego kontenera:

\begin{lstlisting}[caption={Uruchamianie/zatrzymywanie bazy daych z użyciem skryptu w pakiecie api}]
# Uruchomienie
yarn start:db

# Zatrzymanie
yarn stop:db
\end{lstlisting}

W celu sprawdzenia uruchomionych kontenerów w Dockerze (przed uruchomieniem powinno wyświetlić rekord w liście z nazwą \textit{Mongodb}):

\begin{lstlisting}[caption={Wylistowanie uruchomionych kontenerów dockera}]
docker container ls
\end{lstlisting}

\subsection{Aplikacja serwera}

Posiadając uruchomiony wirtualny kontener z bazą danych w konsoli należy przejść do folderu 'packages/api' oraz wpisać następującą komendę w celu uruchomienia serwera:

\begin{lstlisting}[caption={Uruchamianie serwera w pakiecie api}]
yarn start
\end{lstlisting}

\begin{lstlisting}[caption={Uruchamianie serwera w pakiecie api w trybie śledzenia zmian}]
yarn start:dev
\end{lstlisting}

Po prawidłowym wpisaniu komendy uruchomienia, serwer w konsoli powinien zwrócić informacje pod jakim adresem URL serwer aktualnie działa oraz następnie informacje o prawidłowym połączeniu z bazą danych.


Pod wskazanym w konsoli adresem powinna ukazać się strona główna serwera.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/api/stf_api_home.png}
  \caption{Strona Główna Serwera pakietu 'api'}
  \label{fig:mobile}
\end{figure}


\section{Table Manger}
Pakiet 'table-manager' jest odpowiedzialny za zarządzanie procesem działania stołu. Dzięki temu pakietowi jesteśmy w stanie zdalnie uruchamiać, restartować, aktualizować stół oraz analizować logi z działającego procesu aplikacji z pakietu 'table' (z panelu administratora), która dopiero odpowiada za logikę działania systemu po stronie Raspberry Pi. Tym samym ta i następna sekcja będzie stricte związana z częścią fizyczną w związku z tym całe przygotowanie powinno odbyć się na przygotowanym Raspberry Pi.

\subsection{Elektronika}

Paczki 'table-manager' oraz 'table' wymagają fizycznego sprzętu w postaci:

\begin{itemize}
	\item Raspberry Pi z zainstalowanym systemem operacyjnym;
	\item Kamera - Zalecana kamera do systemu to dedykowana kamera 'Camera Module V2' do Raspberry Pi. Możliwe jest również wykorzystanie kamery podłączanej kablem USB;
	\item Sensory do bramek indykujące strzelone gole;
	\item Kable połączeniowe;
	\item Diody LED - Są one opcjonalne ale również zalecane. System zapewnia obsługę 5 diod w 4 różnych kolorach w celu odzwierciedlania różnych stanów systemu podczas swojego działania.
\end{itemize}

W tej sekcji zostanie omówione podłączenie kamery, sensorów bramek oraz diod LED.

\subsubsection{Kamera}

Kamerę należy podłączyć fizycznie do Raspberry poprzez natywny moduł kamery lub USB.

\subsubsection{Sensory bramek}

W celu podłączenia sensorów bramek należy podłączyć dwa czujniki przerwania wiązki IR. Zaprojektowany model bramki przewiduje sensor o wymiarach 20mm x 10mm x 8 mm. W przypadku braku czujników przerwania wiązki, możliwe jest też zastosowanie zwykłych przycisków, podłączonych pod wskazane dla tych czujników GPIO.

\subsubsection{Diody LED - Opcjonalne}
System zapewnia obsługę pięciu diod indykujących stan działania systemu.

\begin{table}[h!]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\multicolumn{1}{|c|}{\textbf{Nazwa}} & \multicolumn{1}{c|}{\textbf{GPIO}} & \textbf{Zalecany kolor} & \textbf{Opis} \\ \hline
\textit{TABLE\_MANAGER\_LIGHT} & 23 & Biały/Niebieski & Działanie table-manager \\ \hline
\textit{GATE\_A\_LIGHT} & 21 & Czerwony & Gol dla zespołu A \\ \hline
\textit{GATE\_B\_LIGHT} & 25 & Czerwony & Gol dla zespołu B \\ \hline
\textit{MATCH\_LIGHT} & 15 & Żółty/Pomarańczowy & Stan meczu \\ \hline
\textit{TABLE\_LIGHT} & 13 & Zielony & Działanie stołu \\ \hline
\end{tabular}
\caption{Tabela diod z domyślnymi GPIO}
\end{table}

Przygotowanie diod wymaga podłączenia pod wskazanymi w tabeli wyżej GPIO. System oferuje również możliwość podłączenia diod pod dowolne GPIO. W tym celu należy zmodyfikować plik GPIO.js dla paczki 'table-manager' oraz 'table'.

\subsection{Oprogramowanie}

\subsubsection{Raspberry}

Następnym krokiem jest zaktualizowanie systemu, dodatków i aplikacji na Raspberry Pi komendą:

\begin{lstlisting}[caption={Aktualizacja Raspberry Pi}]
sudo apt update
sudo apt full-upgrade
\end{lstlisting}

\subsubsection{Kamera}

Uruchomienie wsparcia kamery wymaga włączenia odpowiedniej opcji w konfiguracji. W tym celu w terminalu należy wpisać:

\begin{lstlisting}[caption={Uruchomienie ekranu konfiguracji Raspberry Pi}]
sudo raspi-config
\end{lstlisting}

Po uruchomieniu tej komendy pojawi się okno z możliwością konfiguracji Raspberry. Strzałkami klawiatury należy wybrać opcje 'Interfacing Options',  zaznaczyć 'Camera' oraz zatwierdzić akcję oraz zrestartować urządzenie.

W celu sprawdzenia poprawności działania kamery można użyć komendy:

\begin{lstlisting}[caption={Wykonanie zdjęcia na Raspberry Pi}]
raspistill -v -o test.jpg
\end{lstlisting}

Komenda ta powinna wykonać zdjęcie oraz zapisać je w katalogu domowym pod nazwą test.jpg.

\subsubsection{NVM}

W celu instalacji Node w systemie Raspberry najlepiej jest skorzystać z NVM (Node Version Manager), który pozwala na prostą instalację Node oraz szybkie przełączanie pomiędzy jego różnymi wersjami.

\begin{lstlisting}[caption={Pobranie NVM}]
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash
\end{lstlisting}

\begin{lstlisting}[caption={Konfiguracja NVM}]
export NVM_DIR="$HOME/.nvm"
 [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
 [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion
\end{lstlisting}

\begin{lstlisting}[caption={Sprawdzenie działania NVM}]
nvm -v
\end{lstlisting}

\begin{lstlisting}[caption={Instalacja Node.js w wersji 12 poprzez NVM}]
nvm install 12
\end{lstlisting}

\subsubsection{Yarn}
W celu możliwości zainstalowania zależności projektu i zarządzania pakietami należy zainstalować menadżer pakietów Yarn.

\begin{lstlisting}[caption={Pobieranie yarn}]
curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -echo "deb https://dl.yarnpkg.com/debian/ stable main" | sudo tee /etc/apt/sources.list.d/yarn.list
\end{lstlisting}

\begin{lstlisting}[caption={Instalacja yarn}]
sudo apt update && sudo apt install --no-install-recommends yarn
\end{lstlisting}

Sprawdzenie poprawności działania Yarn (powinno zwrócić aktualnie zainstalowaną wersję).
\begin{lstlisting}[caption={Pobranie aktualnej wersji yarn}]
yarn -v
\end{lstlisting}


\subsubsection{MP4Box}
Rozszerzenie CLI pozwala na konwersje wideo z formatu .h264 do .mp4. Potrzebne jest tylko w środowisku uruchomienia paczek 'table' oraz 'table-manager'.

\begin{lstlisting}[caption={Instalacja MP4Box}]
  sudo apt install -y gpac
\end{lstlisting}


\subsubsection{Automatyczny start - opcjonalne}
Cron jest narzędziem wbudowanym w domyślny system Raspberry Pi. Pozwala on na wykonywanie zaplanowanych zadań w systemie. Z pomocą tego narzędzia jest realizowana możliwość automatycznego uruchomiania pakietu 'table-manager'.\cite{RaspCronDocs}

\begin{lstlisting}[caption={Uruchomienie oraz konfiguracja crontab}]
crontab -e
\end{lstlisting}

Na końcu otworzonego pliku konfiguracyjnego należy dodać poniższą linijkę:
\begin{lstlisting}[caption={Fragment konfiguracji crontab}]
@reboot cd /home/pi/smart-table-football/packages/table-manager && yarn start &
\end{lstlisting}

\subsection{Zmienne środowiskowe}
W przypadku pakietu \textit{table-manager}, również należy skonfigurować zmienne środowiskowe. Proces ich konfiguracji przebiega tak samo jak w sekcji \ref{subsection:envs} - Zmienne Środowiskowe. W przypadku intencji uruchomienia stołu bez pakietu \textit{table-manager}, należy uzupełnić plik \textit{.env} w pakiecie \textit{table}.

\subsection{Uruchomienie}
W pierwszej kolejności należy zainstalować zależności komendą \textit{yarn}. Następnie w przypadku skonfigurowanego automatycznego startu wystarczy uruchomić ponownie Raspberry. W przeciwnym wypadku w konsoli należy przejść do folderu \textit{packages/table-manger} oraz wpisać: \textit{yarn start}.

\section{Table}
Pakiet \textit{table} jest sercem działania systemu po stronie fizycznej projektu. Uruchomieniem jednak tego pakietu zajmuje się działający proces pakietu \textit{table-manager}, tym samym paczka ta nie wymaga manualnego startu. Możliwe jest uruchomienie tego pakietu bez użycia menadżera (przygotowanie takie samo jak w przypadku poprzedniego pakietu), jednak nie jest to zalecane ze względu na brak możliwości zarządzania działaniem stołu, w tym przypadku z poziomu admin panelu.

\section{UI Components}
Pakiet \textit{ui-components} jest zbiorem komponentów oraz konfiguracji wykorzystywanych przez paczki Admin oraz Player. Jednocześnie oparty jest on Storybooka, który umożliwia budowanie graficznych komponentów w odizolowaniu (bez logiki).

W celu uruchomienia Storybooka, w konsoli należy przejść do folderu 'packages/ui-components' oraz wpisać:

\begin{lstlisting}[caption={Uruchamianie aplikacji w pakiecie ui-components}]
yarn storybook
\end{lstlisting}

Ze względu na fakt importowania komponentów oraz konfiguracji w innych pakietach kod źródłowy musi być transpilowany z każdą zmianą. Domyślnie proces budowania paczki jest realizowany z każdym instalowaniem zależności w projekcie. W przypadku chęci wprowadzenia zmian w tym pakiecie, za każdym razem należy wykonać komendę:

Transpiluje kod źródłowy paczki:
\begin{lstlisting}[caption={Budowanie paczki ui-components}]
yarn build
\end{lstlisting}

Uruchamia transpilacje w trybie śledzenia zmian:
\begin{lstlisting}[caption={Uruchamianie budowania paczki ui-components w trybie śledzenia zmian}]
yarn build:watch
\end{lstlisting}

Prawidłowo uruchomiona aplikacja pakietu \textit{ui-components} powinna wyglądać jak na ilustracji \ref{fig:storybook}.

\section{Uruchamianie pakietu \textit{admin} oraz \textit{player}}
Ze względu na ten sam krótki proces uruchomienia pakietów \textit{admin} oraz \textit{player}, uruchomienie tych dwóch pakietów zostanie omówione wspólnie w tej sekcji.

W celu uruchomienia omawianych pakietów należy przejść w konsoli do pakietu 'player' oraz 'admin oraz wpisać:

\begin{lstlisting}[caption={Uruchomienie pakietu player oraz admin}]
yarn start
\end{lstlisting}

Powyższy skrypt uruchomi automatycznie aplikacje gracza w przeglądarce. Istnieje również możliwość skonfigurowania działania aplikacji w sieci lokalnej (np. na telefonie). W tym celu w pliku '.env' w zmiennej 'REACT\_APP\_API\_URL' należy wpisać 'http://{ADRES\_IP\_API}:8080'. Adres ten powinien wskazywać na IP urządzenia na którym uruchomiony jest pakiet 'api'. Dzięki temu aplikacja będzie wiedziała w jaki sposób komunikować się w sieci lokalnej.

Aplikacje z pakietu \textit{admin} oraz \textit{player} oferują również możliwość działania w trybie aplikacji natywnej dzięki podejściu PWA. Przykładowo w przeglądarce Chrome na komputerze, użytkownik podczas korzystania z aplikacji powinien w pasku wyszukiwania widzieć ikonę plusa, która sygnalizuje możliwość zainstalowania lokalnie aplikacji. Tym samym na telefonie podczas korzystania z aplikacji powinna po czasie wyświetlić się informacja o możliwości zainstalowania aplikacji w ekranie głównym, co przedstawia ilustracja \ref{fig:pwa_promt}.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/player/PWA_promt.png}
  \caption{Powiadomienie o instalacji aplikacji}
  \label{fig:pwa_promt}
\end{figure}


\section{Admin}

Pakiet \textit{admin} zakłada obsługę całego systemu z użyciem interfejsu graficznego. W tym miejscu użytkownik z odpowiednimi uprawnieniami, może zarządzać wszystkimi dostępnymi zasobami systemu. Podstawowymi elementami tej aplikacji jest zarządzanie użytkownikami całego systemu oraz stołem. Ilustracja \ref{fig:admin-manage-resource}, przedstawia widok zarządzania zasobami dla listy użytkowników.

\begin{figure}[h!]
  \centering
    \includegraphics[width=\textwidth]{images/admin/adminsList.png}
  \caption{Zarządzanie zasobami w panelu administratora}
  \label{fig:admin-manage-resource}
\end{figure}

W celu utworzenia pierwszego użytkownika z rolą administratora należy w edytorze kodu w pliku 'pacakges/api/src/middleware/index.js' od-komentować fragment kodu poprzedzony komentarzem 'CREATE FIRST ADMIN', następnie przy uruchomionym pakiecie wejść na adres serwera: 'http://localhost:8080/create-first-admin', co utworzy nowego administratora z e-mailem: 'admin@stf.com' oraz hasłem: '123123'. W celu uniknięcia błędów należy natychmiastowo po utworzeniu pierwszego użytkownika ponownie za-komentować omawiany fragment kodu.

\newpage

System umożliwia wysyłanie e-maili do użytkowników systemu z poziomu panelu administratora. Funkcjonalność ta upraszcza formę komunikacji z użytkownikami systemu. Ilustracja \ref{fig:admin-send-mail}, przedstawia widok formularza wysyłania e-maila w aplikacji.

\begin{figure}[h!]
  \centering
    \includegraphics[width=\textwidth]{images/admin/mailer.png}
  \caption{Wysyłanie e-maila w panelu administratora}
  \label{fig:admin-send-mail}
\end{figure}

Poza operacjami typu 'CRUD', drugim najważniejszym elementem pakietu \textit{admin} jest zakładka 'tables'. Umożliwia ona zdalne zarządzanie stołem. Ilustracja \ref{fig:admin-table-manager} przedstawia ekran zdalnego zarządzania stołem. W skład wszystkich funkcji, które można znaleźć w tej zakładce wliczają się:

\begin{itemize}
	\item Status Menadżera (włączony/wyłączony);
	\item Status Stołu (włączony/wyłączony);
	\item Uruchamianie ponowne całego Raspberry Pi;
	\item Włączenie/Wyłączenie serwera stołu;
	\item Aktualizacja oprogramowania stołu (pobieranie zmian ze zdalnego repozytorium na Github.com);
	\item Informacja o ostatniej lokalnej aktualizacji;
	\item Logi systemu;
	\item Możliwość czyszczenia lokalnego logów systemu.
\end{itemize}

\begin{figure}[h!]
  \centering
    \includegraphics[width=\textwidth]{images/admin/table-manager.png}
  \caption{Zarządzanie stołem w panelu administratora}
  \label{fig:admin-table-manager}
\end{figure}

\newpage

\section{Player}
Najważniejszym elementem, z punktu widzenia użytkownika, jest pakiet \textit{player}. Jest to główna aplikacja frontendowa łącząca użytkownika z wszystkimi pozostałymi pakietami. U podstawy oparta jest o te same technologie co pakiet 'admin', tzn. CRA, React, React-Admin. W odróżnieniu jednak od pakietu 'admin' posiada ona wiele dodatkowych oraz zmodyfikowanych elementów w kontekście biblioteki React Admin.

\subsection{Logowanie}
Po uruchomieniu aplikacji, pierwszym widokiem aplikacji powinien być ekran logowania. Domyślnie w bibliotece 'React-Admin' znajduje się wbudowany widok logowania (taki jak w pakiecie 'admin'). W przypadku jednak tego pakietu został utworzony osobny widok logowania, przedstawiony na ilustracji \ref{fig:player-login}, w celu umożliwienia nawigacji do widoku rejestracji lub przypomnienia hasła. Takie podejście zapewnia użytkownikowi pełną kontrolę nad cyklem życia konta. W prosty sposób użytkownik może utworzyć swoje konto lub zresetować bieżące hasło.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.3\textwidth]{images/player/login.png}
  \caption{Formularz logowania w aplikacji gracza}
  \label{fig:player-login}
\end{figure}

\subsection{Rejestracja}

W celu dodania zintegrowanego z panelem logowania formularzu rejestracji, wbudowany widok logowania z biblioteki React Admin musiał zostać nadpisany. Dzięki temu aplikacja gracza z widoku logowania umożliwia nawigacje do formularzu rejestracji, gdzie użytkownik może utworzyć swoje konto, podając swoje dane oraz opcjonalnie załadować awatar. Ilustracja \ref{fig:player-registration}, prezentuje zaimplementowany formularz rejestracji. Oprócz logowania i rejestracji w początkowych komponentach widocznych dla użytkownika znajduje się również formularz przypomnienia hasła.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.8\textwidth]{images/player/registration.png}
  \caption{Formularz rejestracji w aplikacji gracza}
  \label{fig:player-registration}
\end{figure}

\subsection{Potwierdzenie konta}

Ze względów bezpieczeństwa w systemie zostało wprowadzone wymaganie potwierdzenia konta e-mailowego. Każdy nowo zarejestrowany gracz otrzymuje na skrzynkę e-mailową wiadomość z prośbą potwierdzenia e-maila, która została zilustrowana na grafice \ref{fig:verifyEmail}. Zamiarem tego ograniczenia jest zmniejszenie potencjalnych prób zakładania wielu kont przez pojedynczych użytkowników lub botów. Użytkownik, który nie potwierdził swojego konta e-mailowego ma dostęp do aplikacji, lecz nie może tworzyć nowych zespołów lub uczestniczyć w rozgrywce.

\begin{figure}[h!]
  \centering
    \includegraphics[width=\textwidth]{images/api/verify_email.png}
  \caption{E-mail z prośbą potwierdzenia konta e-mailowego}
  \label{fig:verifyEmail}
\end{figure}

Użytkownik klikając w link w e-mailu zostaje przeniesiony do widoku potwierdzającego weryfikacje e-maila, przedstawionego na ilustracji \ref{fig:verfied-email-confirmation}. Próbując otworzyć drugi raz ten sam link użytkownik pewien zobaczyć informacje o błędzie. Po udanej weryfikacji użytkownicy mogą tworzyć własne zespoły oraz uczestniczyć w grach.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/player/verfied_emial_confirmation.png}
  \caption{Widok potwierdzonego e-maila}
  \label{fig:verfied-email-confirmation}
\end{figure}

\subsection{Ekran Główny}

Pierwszym widokiem, po zalogowaniu się lub rejestracji (po rejestracji, użytkownik również zostaje przekierowany automatycznie do aplikacji), jest pulpit gracza. Jest to miejsce w którym, zebrane są wszystkie najważniejsze dla gracza statystyki zbiorcze związane z meczami, golami oraz zespołami. W tym miejscu możemy zarówno utworzyć w szybki sposób nowy mecz, ale również przejrzeć statystyki z ostatnio rozgrywanego. Widok omawianej strony głównej/pulpitu został przedstawiony na ilustracji \ref{fig:dashboard}.

\begin{figure}[h!]
  \centering
    \includegraphics[width=\textwidth]{images/player/dashboard.png}
  \caption{Strona główna aplikacji gracza}
  \label{fig:dashboard}
\end{figure}

Ze względu na założenie dostarczenia użytkownikowi najbardziej zbliżonych doświadczeń korzystania z aplikacji natywnej, podejście budowania interfejsu wykorzystuje założenia 'Material Design'. Material Design jest zestawem zasad projektowania graficznego. Jako wsparcie tego systemu budowany interfejs wykorzystuje bibliotekę komponentów graficznych Material UI, omówioną w rozdziale \ref{section:material-ui}.

W głównym widoku aplikacji znajduje się: skrót tworzenia nowej gry, sekcja z ilością zespołów gracza oraz możliwością zaproszenia użytkownika poprzez e-maila, ogólne statystki z gier, skrót do wyników z ostatniego meczu.

\subsection{Górny pasek aplikacji}

W górnym pasku aplikacji znajdują się między innymi dwie ikony sygnalizujące aktualną dostępność stołu (czy jest w użytkowaniu) oraz jego aktualny stan (czy jest włączony). Poza tymi ikonami użytkownik, z poziomu górnego paska może otworzyć/zamknąć menu, sprawdzić powiadomienia, odświeżyć stan aplikacji lub wejść w ustawienia aplikacji. Przedstawione funkcjonalności przedstawione są na ilustracji \ref{fig:dashboard}, w prawym górnym rogu.

\subsection{Powiadomienia}
W pakiecie \textit{player} został zaimplementowany mechanizm powiadomień w celu informowania użytkowników o zaproszeniach do nowych zespołów, odrzuceniu własnych zaproszeń przez innych graczy lub ogólnych informacji od systemu. Sama logika wysyłania powiadomień znajduje się w pakiecie 'api'. Wysyłanie odbywa się przy pomocy jednej funkcji 'sendNotifications' zdefiniowanej w folderze 'utils'. W swoich argumentach przyjmuje ogólny kontekst biblioteki Feathers, id gracza do którego ma trafić powiadomienie, wiadomość, typ oraz opcjonalnie link. Powiadomienia są osobnym serwisem, ale dzięki wyniesieniu funkcji tworzenia pojedynczego powiadomienia jest to bardzo proste i re-używalne w pozostałej części systemu. Widok listy wszystkich dostępnych powiadomień został przedstawiony na ilustracji \ref{fig:notifications}.

\begin{figure}[h!]
  \centering
    \includegraphics[width=\textwidth]{images/player/notifications.png}
  \caption{Widok listy powiadomień}
  \label{fig:notifications}
\end{figure}

\subsection{Ustawienia}
Aplikacja gracza umożliwia dostosowanie aplikacji względem języka aplikacji oraz motywu. Domyślnie motyw pobierany jest na podstawie tego zdefiniowanego w systemie/środowisku, w którym uruchamiana jest aplikacja. Dzięki temu mając ustawiony w komputerze motyw ciemny, aplikacja gracza domyślnie uruchomi się z takim samym motywem. Ekran ustawień gracza w aplikacji został przedstawiony na ilustracji \ref{fig:settings}.

Poza motywem, użytkownik może również dostosować wyświetlany język. Dzięki zdefiniowanej funkcji w bibliotece React Admin zarządzanie i dodawanie nowych języków jest bardzo proste. W folderze i18n zostały zdefiniowane tłumaczenia dla języka angielskiego oraz polskiego. Idea tłumaczenia opiera się na określonej strukturze obiektu z tłumaczeniem konkretnych elementów, która jest taka sama dla wszystkich plików z tłumaczeniem. W celu wykorzystania tłumaczenia wewnątrz aplikacji należy skorzystać z funkcji 'useTranslate' pochodzącej z biblioteki React Admin, na początku komponentu wywołać ją oraz jej wynik przypisać do funkcji 'translate'. Zwrócona funkcja umożliwi tłumaczenie konkretnie zadeklarowanych obiektów. Przykładowo wywołanie \textit{translate('pos.dashboard.title')}, zwróci główny tytuł widniejący w ekranie głównym aplikacja w zależności od wybranego aktualnie języka.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/player/settings.png}
  \caption{Ustawienia gracza}
  \label{fig:settings}
\end{figure}

\subsection{Profil gracza}
Użytkownik podczas korzystania z aplikacji, może edytować swój profil oraz zarządzać swoim kontem w zakładce 'profil'. Sekcja ta została podzielona na trzy podsekcje. Pierwsza (domyślnie wybrana) skupia informacje użytkownika, które są widziane przez innych graczy. Następną podsekcją są informacje nie edytowalne związane z kontem, w tym: powiązany e-mail, status konta, data stworzenia i ostatniej aktualizacji. Ostatnią zakładką są akcje związane z kontem gracza. W tym miejscu użytkownik może zmienić swoje hasło, wysłać e-mail weryfikacyjny lub trwale usunąć swoje konto. Ilustracja \ref{fig:userProfile} przedstawia zestawienie trzech podsekcji profilu gracza omówionych powyżej.

\begin{figure}[h!]
  \centering
    \includegraphics[width=\textwidth]{images/player/userProfie.jpeg}
  \caption{Edycja profilu gracza}
  \label{fig:userProfile}
\end{figure}

\subsection{Tworzenie zespołu oraz gry}
Każdy użytkownik, który zarejestruje się w aplikacji domyślnie posiada swój własny indywidualny zespół, z którym może rozpoczynać nowe rozgrywki grając jeden na jeden lub jeden na dwóch graczy. W celu utworzenia jednak zespołu dwuosobowego, wymaganym jest przejście do widoku tworzenia zespołu przedstawionego na ilustracji \ref{fig:creating-team}. W tym widoku gracz musi wpisać nazwę nowego zespołu oraz wpisać e-mail drugiego zarejestrowanego użytkownika (system pozwala na zaproszenie tylko zarejestrowanych graczy).

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.8\textwidth]{images/player/creating-team.png}
  \caption{Tworzenie nowego zespołu}
  \label{fig:creating-team}
\end{figure}

W celu stworzenia nowej gry należy przejść do widoku 'gry' oraz kliknąć 'stwórz'. W widoku tworzenia nowej gry przedstawionego na grafice \ref{fig:create-match}, gracz musi wybrać jeden ze swoich zespołów, zespół przeciwny oraz ilość sekund, która określa długość nagrań powtórek.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/player/create-match.png}
  \caption{Tworzenie nowej gry}
  \label{fig:create-match}
\end{figure}

\subsection{Widok gry}
Użytkownik po utworzeniu nowego meczu lub wybraniu kontynuacji starego przechodzi do widoku gry przedstawionego na ilustracji \ref{fig:match}. W jednym momencie w widoku gry może znajdować się wielu graczy. W celu rozpoczęcia rozgrywki jeden z graczy musi wcisnąć przycisk 'start'. W tym momencie zielona dioda podłączona do stołu powinna się zaświecić oraz licznik czasu powinien zacząć naliczanie czasu. Od tego momentu system oznacza stół jako zajęty, co dla innych graczy oznacza brak możliwości rozpoczęcia rozgrywki oraz zmianę ikony w górnym pasku aplikacji na stół zajęty.

\begin{figure}[h!]
  \centering
    \includegraphics[width=\textwidth]{images/player/match.png}
  \caption{Główny widok gry}
  \label{fig:match}
\end{figure}

Po rozpoczęciu meczu, każdy gol, który zostanie strzelony będzie zapisany w systemie oraz zostanie nagrana jego powtórka z pomocą kamery. Podczas każdego gola, w pierwszej kolejności zapala się czerwona dioda przypisana do bramki. W następstwie zapalenia diody, nagranie bramki jest zapisywane na dysku Google oraz odtwarzane w widoku gry. Powtórka odtwarzana jest w tymczasowym powiadomieniu o nowym golu przedstawionym na ilustracji \ref{fig:newGoal}, w tym samym momencie, użytkownik może anulować ostatni gol.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{images/player/newgoal.png}
  \caption{Powiadomienie o nowym golu}
  \label{fig:newGoal}
\end{figure}

\subsection{Historia goli w grze}
W ekranie gry, każdy użytkownik może w dowolnym momencie sprawdzić historie goli przedstawioną na ilustracji \ref{fig:goals-history}, która znajduje się pod tabelą z wynikiem. Lista goli pozwala na usuwanie oraz oglądanie powtórek wybranych goli.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.7\textwidth]{images/player/goals history.png}
  \caption{Historia goli w widoku gier}
  \label{fig:goals-history}
\end{figure}

\subsection{Lista gier i zespołów}
W głównym menu aplikacji, dwoma ostatnimi elementami jest kolejno lista zespołów oraz lista gier aktualnie zalogowanego gracza. Obydwie listy implementują mechanizm sortowania (kliknięcie w nagłówek kolumny) oraz filtrowania po kluczowych polach tych zasobów. Przykładowa lista zespołów została przedstawiona na ilustracji \ref{fig:list-filters}.
Dzięki ustandaryzowanemu podejściu w komunikacji serwera z aplikacją (REST) oraz implementacji biblioteki React Admin, funkcjonalności sortowania i filtrowania wymagają jedynie zadeklarowania, które pola mają być brane pod uwagę (sortowanie ustawione jest domyślnie dla wszystkich elementów).

\begin{figure}[h!]
  \centering
    \includegraphics[width=\textwidth]{images/player/listFilters.png}
  \caption{Filtrowanie listy zespołów}
  \label{fig:list-filters}
\end{figure}
